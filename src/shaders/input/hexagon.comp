#version 460
layout(local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D texture;

layout (location = 0) uniform float radius;
layout (location = 1) uniform float time;

bool insideTriangle(float angle, float hexagonRadius)
{
	// Define the coordinates of the triangle's vertices
	vec2 v1 = vec2(1920/2, 1080/2); // Top vertex

	float x = cos(radians(60.0)) * hexagonRadius;
	float y = sin(radians(60.0)) * hexagonRadius;
	vec2 v2 = vec2(1920/2 - x, 1080/2 - y); // Left vertex
	vec2 v3 = vec2(1920/2 + x, 1080/2 - y); // Right vertex

	// Calculate the center point of the triangle
	vec2 center = v1;

	// Define the rotation angle in radians
	float theta = radians(angle);

	// Define the rotation matrix
	mat2 rotationMatrix = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));

	// Rotate each vertex around the center point
	v1 = rotationMatrix * (v1 - center) + center;
	v2 = rotationMatrix * (v2 - center) + center;
	v3 = rotationMatrix * (v3 - center) + center;

	vec2 p = vec2(gl_GlobalInvocationID.xy);
	return (p.x - v1.x) * (v2.y - v1.y) - (p.y - v1.y) * (v2.x - v1.x) < 0 &&
						(p.x - v2.x) * (v3.y - v2.y) - (p.y - v2.y) * (v3.x - v2.x) < 0 &&
						(p.x - v3.x) * (v1.y - v3.y) - (p.y - v3.y) * (v1.x - v3.x) < 0;
}

bool insideHexagon(float borderSize)
{
	bool insideLargerHexagon = false;
	for (int i = 0; i < 360; i += 60)
	{
		if (insideTriangle(float(i), radius))
		{
			insideLargerHexagon = true;
			if (borderSize == 0)
				return true;
			break;
		}
	}
	for (int i = 0; i < 360; i += 60)
	{
		if (insideTriangle(float(i), radius - borderSize))
			return false;
	}
	return insideLargerHexagon;
}

void main()
{
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec4 existingPixel = imageLoad(texture, pixel_coords);

	if (insideHexagon(10))
		existingPixel.b = 1;

	imageStore(texture, pixel_coords, existingPixel);
}
